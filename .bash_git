#!/usr/bin/env bash
# $DOTFILES_DIR/.bash_git: git aliases and functions, sourced from .bashrc

require "$DOTFILES_DIR/.bash_colors"
require "$DOTFILES_DIR/.bash_shared_functions"


# shared functions

in_git_repo() {
  git status >/dev/null && return 0 || echo_err "Not in git repo" && return 1
}

# for LinkedIn workflow
git_review_board_id() {
  echo "$(git config --get branch.$1.reviewid)"
}

current_git_branch() {
  echo "$(git rev-parse --abbrev-ref HEAD)"
}

on_git_branch() {
    [ "$(current_git_branch)" != "$1" ] && echoerr ">_<  Must be on branch '$1' for this" && return -1 || return 0
}

not_on_git_branch() {
    [ "$(current_git_branch)" == "$1" ] && echoerr ">_<  Doesn't work on branch '$1'" && return -1 || return 0
}

# check that repo is currently on a branch (not a tag or detached or anything else)
on_symbolic_ref() {
  git symbolic-ref HEAD
}

no_uncommitted_changes() {
    [ "$(git status --porcelain --untracked-files=no)" != "" ] && echoerr ">_<  You have uncommitted changes" && return -1 || return 0
}

# number of changes between two input branches
# (typically a branch and master, or master and origin/master)
commit_diff_on_branch() {
    local git_rev_list_origin="$(git rev-list --count --left-right "$1"..."$2" 2>/dev/null)"
    if [ "$?" -eq 0 ] && [ -n "$git_rev_list_origin" ]; then
        local git_origin_arr=($git_rev_list_origin) # splits into array - it's 2 numbers separated by spaces
        echo "${git_origin_arr[0]}"
    else
        echo "0"
    fi
}

# files changed on the current branch
file_diff_on_branch() {
  local tracking_branch="$(based_on_master_or_origin)"
  echo "$(git diff-tree --no-commit-id --name-only -r "$tracking_branch" HEAD)"
}

based_on_master_or_origin() {
  # adapted from https://stackoverflow.com/a/9753364
  local tracking_branch="$(git rev-parse --abbrev-ref --symbolic-full-name $1@{u} 2>/dev/null)"
  if [ "$tracking_branch" == "origin/master" ]; then
    echo "origin/master"
  else
    echo "master"
  fi
}

# squash the input number of commits on the current branch
# $1: number of commits to squash
# $2: commit message
# $3: extra line for message (extra info, overrides, etc.)
squash_commits() {
  if [ -n "$1" ] && [ "$1" -gt 0 ]; then
    if [ -n "$2" ]; then
      if [ -n "$3" ]; then
        # multiple lines of commit messages
        do_git reset --soft HEAD~${1} && do_git commit -m "$2" -m "$3"
      else
        # "squash" commits by combining all into a single commit (from SO)
        do_git reset --soft HEAD~${1} && do_git commit -m "$2"
      fi
      if [ "$?" -ne 0 ]; then
        echoerr "Dang it! Squashing commits failed somehow"
        return 1;
      fi
    else
      echoerr "Come on! You gotta have a commit message"
      return 1;
    fi
  else
    echoerr "-_- No changes to squash"
    return 1;
  fi
  return 0;
}

# run git with the input arguments
do_git() {
  do_cmd git "$@"
}

# list all branches
all_git_branches() {
  echo $(git for-each-ref --format="%(refname)" refs/heads/ | sed 's|refs/heads/||')
}

# undo the last merge that was done (usually because something failed)
git_undo_merge() {
  do_git reset --merge ORIG_HEAD && do_git checkout "$1"
}

# this RB stuff should probably go in a separate file...

# get the API definition for review board at LinkedIn
get_li_rb_api_def() {
  local api_def=""
  local cache_file="$DOTFILES_DIR/cache/li-rb-api-def.cache"
  local cache_file_expired="$(find $cache_file -mtime +1)" # if cache file is older than 1 day

  if [ -n "$cache_file_expired" ]; then
    echoerr "RB API definitions not cached, requesting..."
    api_def="$(curl -X GET -H 'Accept: application/json' 'https://rb.corp.linkedin.com/api/' 2>/dev/null)"
    echo_info "return code: $?"
    # TODO check return code for error
    echo "$api_def" > "$cache_file"
  else
    api_def=$(<"$cache_file")
  fi
  echo "$api_def"
}

# get the template to use for querying the RB api
get_li_rb_uri_template() {
  local template="$(get_li_rb_api_def | jq ".uri_templates.$1")"
  echo "$(trim_double_quotes $template)"
}

# get RB status
get_li_rb_status() {
  if [ -n "$1" ]; then
    local api_uri_template=$(get_li_rb_uri_template "review_request")
    # echo $api_uri_template
    local request_url=${api_uri_template/\{review_request_id\}/$1}
    # echo $request_url
    if [ -n "$request_url" ]; then
      local status=$(curl -X GET -H 'Accept: application/json' "$request_url" 2>/dev/null | jq '.review_request.status')
      echo "$(trim_double_quotes $status)"
    fi
  fi
}

# parse input repo URL, returning user and repo separated by a space
git_parse_repo_url() {
  repo_url="$1"
  if [[ "$repo_url" =~ ^git@ ]]
  then
    # example: git@github.com:octocat/Hello-World.git
    trim_front="${repo_url#git@github.com:}" # remove the initial "git@github.com:"
    trim_back="${trim_front%.git}" # remove the trailing ".git"
    echo "${trim_back/\// }" # replace the separating "/" with " "
  elif [[ "$repo_url" =~ ^https ]]
  then
    # example: https://github.com/octocat/Hello-World.git
    trim_front="${repo_url#https://github.com/}" # remove the initial "https://github.com/"
    trim_back="${trim_front%.git}" # remove the trailing ".git"
    echo "${trim_back/\// }" # replace the separating "/" with " "
  fi
}

# functions

# git - apply a patch to a new branch, named after the input .patch file (from gbpatch)
gbapply() {
  arguments=('<patch-file>')
  if in_git_repo && on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
  then
    local patch_file="$1"
    local new_branch_name=$(basename "$patch_file")
    do_git checkout -b "${new_branch_name%.*}" && do_git apply --check "$patch_file" && do_git apply "$patch_file"
  fi
}

# git - list branches (git branch list)
gbl() {
  do_git branch --list
}

# git - list branches with RB and status (will be slow)
gbls() {
  for branch in $(all_git_branches); do
    local review_id=$(git config --get branch.$branch.reviewid)
    local review_status=$(get_li_rb_status $review_id)
    # to make things nicer to look at
    if [ "$review_status" == "submitted" ]; then
      review_status="$(echo -e "${COLOR_FG_DARK_GRAY}$review_status${COLOR_RESET}")"
    fi
    if [ "$review_status" == "pending" ]; then
      review_status="$(echo -e "${COLOR_FG_YELLOW}$review_status${COLOR_RESET}")"
    fi

    if [ -n "$review_id" ]; then
      printf "${COLOR_FG_BOLD_BLUE}%-25s${COLOR_RESET} https://rb.corp.linkedin.com/r/%-10s %s\n" $branch $review_id $review_status
    else
      printf "%-25s\n" $branch
    fi
  done
}

# git - list local and remote branches (git branch list all)
gbla() {
  do_git branch --list -a
}

# git - create a patch from the current branch (for use with gbapply)
gbpatch() {
  arguments=()
  if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
  then
    local branch_name=$(current_git_branch)
    local tracking_branch=$(based_on_master_or_origin)
    do_git format-patch $tracking_branch --stdout > "${branch_name}.patch"
  fi
}

# git - checkout branch/tag/hash (git checkout)
gc() {
  arguments=('<branch-tag-or-hash>')
  if in_git_repo && num_arguments_ok arguments[@] "$#"
  then
    do_git checkout "$1"
  fi
}

# git - create new branch
gcb() {
  arguments=( '<new-branch-name>' )
  if in_git_repo && num_arguments_ok arguments[@] "$#"
  then
    do_git checkout -b "$1"
  fi
}

# git - create new branch (that tracks origin/master)
gcbm() {
  arguments=( '<new-branch-name>' )
  if in_git_repo && num_arguments_ok arguments[@] "$#"
  then
    do_git checkout -b "$1" origin/master
  fi
}

# git - gui (git gui)
gg() {
  do_git gui
}

# git - show last commit info - (git last)
glast() {
  do_git log -n1
}

# TODO support more than *.js files
# git - run linter on files changed on this branch (git lint changes)
glc() {
  local changed_files=$(file_diff_on_branch)
  # for eslint, have to have nvm loaded
  if [ -z "$NVM_BIN" ]; then load_nvm; fi

  echo "$changed_files" | xargs eslint --config ~/dotfiles/.eslintrc.json --plugin extra-rules --rule 'extra-rules/no-commented-out-code: warn'
}

# git - run mergetool for conflicts (git mergetool)
gmt() {
  # TODO: different tool for Mac/Linux
  do_git mergetool --tool=opendiff
}

# git - push changes (git push)
gp() {
  do_git push
}

# git - push current local branch to origin, and set upstream
gpb() {
  arguments=()
  if in_git_repo && not_on_git_branch 'master' && num_arguments_ok arguments[@] "$#"
  then
    local branch_name=$(current_git_branch)
    do_git push -u origin "$branch_name"
  fi
}

# git - pull changes from origin, with rebase (git pull rebase)
gpr() {
  # sometimes `git pull --rebase` fails with "fatal: Cannot rebase onto multiple branches."
  # so try doing the full command (https://stackoverflow.com/a/35844073)
  local branch_name=$(current_git_branch)
  do_git pull origin $branch_name --rebase
}

alias grc='gr'
# git - create review for LI workflow (git review create)
gr() {
  # TODO: prompt for things, with defaults
  # usage: git-review create [-h] [-r REVIEWERS] [-g GROUPS] [--acl-groups]
  #                        [--branch BRANCH] [--parent PARENT] [--guess-desc]
  #                        [-m DESCRIPTION] [-b BUGS] [-p] [--debug]
  #                        [--rbt-flags RBT_FLAGS] [-o] [--release-only]
  #                        [--owners-only] [--no-prompt] [--open]
  #                        [--testing-done TESTING_DONE]
  #
  # Create a new Gerrit/Review Board request.
  #
  # optional arguments:
  #   -h, --help            show this help message and exit
  #   -r REVIEWERS, --reviewers REVIEWERS
  #                         Comma separated list of reviewers
  #   -g GROUPS, --groups GROUPS
  #                         Comma separated list of review groups
  #   --acl-groups          Add acl groups from acl files as reviewers (for
  #                         notification purposes)
  #   --branch BRANCH       Local branch to use. [default: master]
  #   --parent PARENT       Commit to compare review against. Example: --parent
  #                         HEAD~1. Example2: --parent <<commit hash>>
  #   --guess-desc          Guess the summary & description.
  #   -m DESCRIPTION, --description DESCRIPTION
  #                         Description of the review.
  #   -b BUGS, --bugs BUGS  Associated JIRA ID(s)
  #   -p, --publish         Publish review immediately. [default: False]
  #   --debug               Show debugging information. [default: False]
  #   --rbt-flags RBT_FLAGS
  #                         Additional flags to pass on to rbt. Start flags with a
  #                         space. Example: --rbt-flags " --parent COMMIT_HASH"
  #   -o, --owners          Add all owners of all files as reviewers, does not add
  #                         people in acl-of-last-resort.acl or new-service.acl
  #   --release-only        Add only the release owners as reviewers, does not add
  #                         people in acl-of-last-resort.acl or new-service.acl
  #   --owners-only         Add acl owners only (no release owners) of all files
  #                         as reviewers, does not add people in acl-of-last-
  #                         resort.acl or new-service.acl
  #   --no-prompt           Do not prompt for additional reviewers or groups.
  #   --open                Open your browser with the review request just
  #                         created.
  #   --testing-done TESTING_DONE
  #                         Add to the testing done section.

  # TODO: use `expect` to automatically answer the prompts, which look like this (2 prompts):
  # expect <<EndOfGitReviewExpect
  #   spawn do_git review create
  #   # No ACL owners have been added, but review request creation process will continue.
  #   # Recommended reviewers are: blah (Blob Loblaw)
  #   expect "Additional reviewers (users and groups), comma-delimited [leave blank to skip]:"
  #   send "flagship-productivity-reviewers\r"
  #   # Warning: You are missing owners needed on your review to push this change.
  #   # Choose "n" to list owners per file and select them individually.
  #   expect "Would you like to add all owners (y or n)?:"
  #   send "y\r"
  #   # ⠏Review request #1155923 posted.
  #   expect eof
# EndOfGitReviewExpect
  do_git review create
}

# git - apply diff from review board to repo (git review apply)
gra() {
  echoerr "TODO"
  # usage: git-review apply [-h] [-a] [-c {master,review,current}] [-d DIFF]
  #                         [-l LOCATION] [-n]
  #                         reviewid
  #
  # Given a reviewboard request clean up the repo and apply the diff locally
  #
  # positional arguments:
  #   reviewid              Review id to apply locally
  #
  # optional arguments:
  #   -h, --help            show this help message and exit
  #   -a, --commit          Commit the patch.
  #   -c {master,review,current}, --commitid {master,review,current}
  #                         Apply review diff to fresh checkout of the repo in the
  #                         review
  #   -d DIFF, --diff DIFF  Choose the diff to apply
  #   -l LOCATION, --location LOCATION
  #                         Choose destination directory.
  #   -n, --no-new-dir      Apply review diff to the current repo
}

# git - rebase current branch against master
gram() {
  arguments=()
  if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
  then
    local branch_name=$(current_git_branch)
    local need_to_remove_orig_files='no'
    do_git checkout master && gpr && do_git checkout "$branch_name" && do_git rebase master
    while [ "$?" -ne 0 ]; do
      need_to_remove_orig_files='yes'
      gmt && do_git rebase --continue
      # TODO: how to detect that I should abort?
    done
    # delete any *.orig files leftover from merge conflicts
    if [ "$need_to_remove_orig_files" == 'yes' ]; then
      echo_info "Cleaning up .orig files from merge conflicts..."
      grmorig
    fi
  fi
}

# git - show ACLs needed for review, with optional RB_ID (git review dcommit)
grd() {
  if [ -n "$1" ]
  then
    do_git review dcommit -r "$1"
  else
    do_git review dcommit
  fi
}

# git - update remote tracking branch (git remote update)
gremu() {
  do_git remote update
}

# git - delete *.orig files, usually leftover after merge or rebase with conflicts
grmorig() {
  do_git ls-files --others --exclude-standard | do_cmd grep \.orig$ | do_cmd xargs rm -v
}

# git - show status of RB - which ACLs are needed (git review status)
grs() {
  do_git review status
}

# git - update RB with new changes (git review update)
gru() {
  do_git review update
  # TODO: prompt for more options:
  # usage: git-review update [-h] [-r REVIEWID] [-m DIFF_DESCRIPTION]
  #                          [--update-desc] [--branch BRANCH] [--parent PARENT]
  #                          [-p] [--debug] [--rbt-flags RBT_FLAGS] [--open]
  #                          [--testing-done TESTING_DONE]
  #
  # Update an existing Review Board request with a new diff.
  #
  # optional arguments:
  #   -h, --help            show this help message and exit
  #   -r REVIEWID, --reviewid REVIEWID
  #                         Review Board ID to update.
  #   -m DIFF_DESCRIPTION, --diff-description DIFF_DESCRIPTION
  #                         A description of what changed in this update of the
  #                         review request. This is ignored for new review
  #                         requests.
  #   --update-desc         The new contents for the Description field based on
  #                         the commit message.
  #   --branch BRANCH       Local branch to use. [default: master]
  #   --parent PARENT       Commit to compare review against. Example: --parent
  #                         HEAD~1. Example2: --parent <<commit hash>>
  #   -p, --publish         Publish review immediately. [default: False]
  #   --debug               Show debugging information. [default: False]
  #   --rbt-flags RBT_FLAGS
  #                         Additional flags to pass on to rbt
  #   --open                Open your browser with the review request just
  #                         created.
  #   --testing-done TESTING_DONE
  #                         Update the testing done section.
}

# git - stash uncommitted changes (git stash)
gs() {
  do_git stash
}

# git - apply stashed changes (git stash apply [stash])
gsa() {
  if [ -n "$1" ]; then
    do_git stash apply "$1"
  else
    do_git stash apply
  fi
}

# git - dtop stashed changes (git stash drop [stash])
gsd() {
  if [ -n "$1" ]; then
    do_git stash drop "$1"
  else
    do_git stash drop
  fi
}

# git - list all stashes (git stash list)
gsl() {
  do_git stash list
}

# git - pop the last stash (git stash pop)
gsp() {
  do_git stash pop
}

# git - stash current changes with a message (git stash save)
gss() {
  arguments=('<message>')
  if in_git_repo && num_arguments_ok arguments[@] "$#"
  then
    do_git stash save "$1"
  fi
}

# git - show repo status (git status)
gstat() {
  do_git status
}

# git - undo the last commit (git undo)
gundo() {
  do_git reset --soft HEAD~1
}

# git - (meta) show git functions from this file
gfun() {
  printf "\nFunctions:\n"
  # list of functions and descriptions
  git_functions=$(sed -n -e '/^# git/{ h; n; G; s/\n//; s/{# git - //; p; }' "$DOTFILES_DIR/.bash_git" | sort)
  while read -r func text; do
    printf "%10s - %s\n" "$func" "$text"
  done <<< "$git_functions"
}

# git - show the current commit hash
gcurr() {
    arguments=()
    if in_git_repo && num_arguments_ok arguments[@] "$#"
    then
        ( set -x; git rev-parse HEAD; git rev-parse --short HEAD; )
    fi
}

# git - sync current branch to the upstream fork (Git Fork Sync)
gfs() {
  arguments=()
  if in_git_repo && on_symbolic_ref && num_arguments_ok arguments[@] "$#"
  then
    local branch_name=$(current_git_branch)
    do_git fetch upstream && do_git merge "upstream/$branch_name" && do_git push
  fi
}

# git - fork a repo from github and clone locally (Git Fork & Clone)
gfc() {
  arguments=('<repo-url>')
  if num_arguments_ok arguments[@] "$#"
  then
    input_url="$1"
    repo_info=( $(git_parse_repo_url $input_url) ) # will split into array because it's 2 strings separated by space
    username=${repo_info[0]}
    repo_name=${repo_info[1]}

    # create fork from original repo (TODO - make this a separate function?)
    api_token="$($HOME/Dropbox/secret/get-api-token github-fork-token)"
    # not using do_cmd here because I don't want the API token echoed to the screen
    echo_ack "(curl -X POST -u mikrostew:XXXXX 'https://api.github.com/repos/$username/$repo_name/forks')"
    output="$(curl -X POST -u mikrostew:$api_token "https://api.github.com/repos/$username/$repo_name/forks")"
    # (running that multiple times won't create multiple forks)
    # TODO - check output for error

    echo_info "Waiting 10 seconds for github to create the fork..."
    sleep 10

    # clone the repo locally (use the 'ssh_url' property from the returned JSON)
    ssh_url="$(trim_double_quotes $(echo $output | jq '.ssh_url'))"
    do_git clone "$ssh_url" "$repo_name"
    # check for error, wait, and retry once if it failed
    if [ "$?" -ne 0 ]
    then
      echo_info "Waiting 10 more seconds and retrying once..."
      sleep 10
      do_git clone "$ssh_url" "$repo_name"
      # if it failed again then something is wrong
      if [ "$?" -ne 0 ]; then
        return
      fi
    fi

    # cd into that folder && set upstream to the original repo
    cd "$repo_name" && do_git remote add upstream "$input_url"
    do_git remote -v
  fi
}

# git - merge current branch into master
gmm() {
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git checkout master && git merge "$branch_name" )
    fi
}

# git - move recent commits from master to a new branch
gmove() {
  arguments=( '<new-branch-name>' )
  if in_git_repo && on_git_branch 'master' && num_arguments_ok arguments[@] "$#"
  then
    local num_commits="$(commit_diff_on_branch 'master' 'origin/master')"
    echo "${num_commits} commit(s) will be moved to branch '$1'"
    if [ "$num_commits" != "" ] && [ "$num_commits" -gt 0 ]; then
      # (see http://stackoverflow.com/a/22654961 for details)
      do_git checkout -b "$1" && do_git branch -f master HEAD~${num_commits} && do_git branch -u origin/master "$1"
    fi
  fi
}

# git - rebase current branch against master (using 'mint update' instead of 'git pull')
mram() {
    # TODO: use gram() and check if I'm in a MP
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git checkout master && mint update && git checkout "$branch_name" && git rebase master )
    fi
}

# git - show which files are different from master branch
gfiles() {
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git diff --name-status master.."$branch_name" )
    fi
}

# git - squash commits in current branch into a single commit (git squash branch)
gsqb() {
  arguments=( '<commit-message> [, <extra-line>]' )
  if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_min arguments[@] "$#"
  then
    local branch_name=$(current_git_branch)
    local based_on=$(based_on_master_or_origin $branch_name)
    # TODO: this may not be what I want in all situations?
    local num_commits_on_branch="$(commit_diff_on_branch $branch_name $based_on)"
    echo_info "$num_commits_on_branch change(s) between '$branch_name' and '$based_on'"
    echo -n "Confirm squashing $num_commits_on_branch commits [Y/n]: "
    read confirm
    if [ -z "$confirm" ] || [ "$confirm" == "Y" ] || [ "$confirm" == "y" ]
    then
      squash_commits "$num_commits_on_branch" "$1" "$2"
    else
      echo "Not squashing"
    fi
  else
    return -1;
  fi
}

# git - branch move (rename current branch)
gbm() {
  arguments=( '<new-branch-name>' )
  if in_git_repo && num_arguments_ok arguments[@] "$#"
  then
    do_git branch --move "$1"
  fi
}

# TODO: generalize this for whatever input URL
# git - wait on github to be pingable (pings every 60 seconds)
wait_github() {
    until ping -i 60 -o github.com
    do
        sleep 60
    done
    echoack "github available"
}

# release npm project
#  - update version in package.json
#  - commit with version in commit message
#  - publish to npm
release() {
  # (adapted from https://github.com/stefanpenner/dotfiles/blob/master/.config/fish/config.fish)
  if in_git_repo
  then
    tag="${1:?Must include a tag argument}"
    current_branch="$(current_git_branch)"

    # need to use npm
    if [ -z "$NVM_BIN" ]; then load_nvm; fi

    if [ -f package.json ]; then
      do_cmd jq ".version=\"$tag\"" < package.json | do_cmd sponge package.json
      do_git add ./package.json
    fi

    do_git commit -m "release v$tag 🎉"
    do_git tag "v$tag"
    do_git push origin "$current_branch" "v$tag"

    if [ -f package.json ]; then
      do_cmd npm publish
    fi

    echo_info "released as v$tag 🎉"
    echo -n "released as v$tag 🎉" | pbcopy
  fi
}

