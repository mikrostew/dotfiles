# aliases and functions for git
ALIAS_COLOR='\033[0;32m'
ALIAS_RESET='\033[0m'

alias gbl='echo -e "${ALIAS_COLOR}(git branch --list)${ALIAS_RESET}"; git branch --list'
alias gbla='echo -e "${ALIAS_COLOR}(git branch --list -a)${ALIAS_RESET}"; git branch --list -a'
alias gc='echo -e "${ALIAS_COLOR}(git checkout [branch])${ALIAS_RESET}"; git checkout'
alias gcb='echo -e "${ALIAS_COLOR}(git checkout -b [new-branch])${ALIAS_RESET}"; git checkout -b'
alias gg='echo -e "${ALIAS_COLOR}(git gui)${ALIAS_RESET}"; git gui'
alias gmt='echo -e "${ALIAS_COLOR}(git mergetool --tool=opendiff)${ALIAS_RESET}"; git mergetool --tool=opendiff'
alias gp='echo -e "${ALIAS_COLOR}(git push)${ALIAS_RESET}"; git push'
alias gpr='echo -e "${ALIAS_COLOR}(git pull --rebase)${ALIAS_RESET}"; git pull --rebase'
alias gr='echo -e "${ALIAS_COLOR}(git review)${ALIAS_RESET}"; git review'
alias grd='echo -e "${ALIAS_COLOR}(git review dcommit [-r RB_ID])${ALIAS_RESET}"; git review dcommit'
alias gremu='echo -e "${ALIAS_COLOR}(git remote update)${ALIAS_RESET}"; git remote update'
alias grs='echo -e "${ALIAS_COLOR}(git review status)${ALIAS_RESET}"; git review status'
alias gru='echo -e "${ALIAS_COLOR}(git review update)${ALIAS_RESET}"; git review update'
alias gs='echo -e "${ALIAS_COLOR}(git stash)${ALIAS_RESET}"; git stash'
alias gsa='echo -e "${ALIAS_COLOR}(git stash apply [stash])${ALIAS_RESET}"; git stash apply'
alias gsd='echo -e "${ALIAS_COLOR}(git stash drop [stash])${ALIAS_RESET}"; git stash drop'
alias gsl='echo -e "${ALIAS_COLOR}(git stash list)${ALIAS_RESET}"; git stash list'
alias gsp='echo -e "${ALIAS_COLOR}(git stash pop)${ALIAS_RESET}"; git stash pop'
alias gss='echo -e "${ALIAS_COLOR}(git stash save <message>)${ALIAS_RESET}"; git stash save'
alias gstat='echo -e "${ALIAS_COLOR}(git status)${ALIAS_RESET}"; git status'
alias gundo='echo -e "${ALIAS_COLOR}(git reset --soft HEAD~1)${ALIAS_RESET}"; git reset --soft HEAD~1'


# shared functions

function in_git_repo() {
    git status >/dev/null && return 0 || return 1
}

function current_git_branch() {
    echo "$(git rev-parse --abbrev-ref HEAD)"
}

function on_git_branch() {
    [ "$(current_git_branch)" != "$1" ] && echoerr ">_<  Must be on branch '$1' for this" && return -1 || return 0
}

function not_on_git_branch() {
    [ "$(current_git_branch)" == "$1" ] && echoerr ">_<  Doesn't work on branch '$1'" && return -1 || return 0
}

function no_uncommitted_changes() {
    [ "$(git status --porcelain --untracked-files=no)" != "" ] && echoerr ">_<  You have uncommitted changes" && return -1 || return 0
}

# number of changes between input branch and origin/master
function commit_diff_on_branch() {
    local git_rev_list_origin="$(git rev-list --count --left-right "$1"...origin/master 2>/dev/null)"
    if [ "$?" -eq 0 ] && [ -n "$git_rev_list_origin" ]; then
        local git_origin_arr=($git_rev_list_origin) # splits into array - it's 2 numbers separated by spaces
        echo "${git_origin_arr[0]}"
    fi
}

# squash the input number of commits on the current branch
function squash_commits() {
    if [ "$1" != "" ] && [ "$1" -gt 0 ]; then
        # "rebase" without having to do things interactively (from Stack Overflow)
        ( set -x; git reset --soft HEAD~${1} && git commit -m "$2" )
        if [ "$?" -ne 0 ]; then
            echoerr "Dang it! Squashing commits failed"
            return -1;
        fi
    else
        echoerr "-_- No changes to squash"
        return -1;
    fi
    return 0;
}


# functions

# git - create a patch from the current branch
function gbpatch() {
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git format-patch master --stdout > "${branch_name}.patch" )
    fi
}

# git - apply a patch to a new branch, named after the input .patch file
function gbapply() {
    arguments=('<patch-file>')
    if in_git_repo && on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
    then
        local patch_file="$1"
        local new_branch_name=$(basename "$patch_file")
        ( set -x; git checkout -b "${new_branch_name%.*}" && git apply --check "$patch_file" && git apply "$patch_file" )
    fi
}

# git - (meta) show git aliases and functions from this file
function gcom() {
    arguments=()
    if num_arguments_ok arguments[@] "$#"
    then
        printf "\nAliases:\n"
        # list of the aliased commands, without 'alias', 'echo', or parenthesis
        git_aliases=$(alias | grep git | sed -e 's/alias //' -e "s/='echo -e \"\${[A-Z_]*}(.*)\${[A-Z_]*}\";//" -e "s/'$//")
        while read -r cmd_alias cmd; do
            printf "%6s = %s\n" "$cmd_alias" "$cmd"
        done <<< "$git_aliases"

        printf "\nFunctions:\n"
        # list of functions and descriptions
        git_functions=$(sed -n -e '/^# git/{ h; n; G; s/\n//; s/function //; s/{# git - //; p; }' "$DOTFILES_DIR/.bash_git" | sort)
        while read -r func text; do
            printf "%10s - %s\n" "$func" "$text"
        done <<< "$git_functions"
    fi
}

# git - show the current commit hash
function gcurr() {
    arguments=()
    if in_git_repo && num_arguments_ok arguments[@] "$#"
    then
        ( set -x; git rev-parse HEAD; git rev-parse --short HEAD; )
    fi
}

# git - sync current branch to the upstream fork (Git Fork Sync)
function gfs() {
    arguments=()
    if in_git_repo && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git fetch upstream; git merge "upstream/$branch_name"; git push )
    fi
}

# git - merge current branch into master
function gmm() {
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git checkout master && git merge "$branch_name" )
    fi
}

# git - move recent commits to a new branch (instead of master)
function gmove() {
    arguments=( '<new-branch-name>' )
    if in_git_repo && on_git_branch 'master' && num_arguments_ok arguments[@] "$#"
    then
        local num_commits="$(commit_diff_on_branch 'master')"
        echo "${num_commits} commit(s) will be moved to branch '$1'"
        if [ "$num_commits" != "" ] && [ "$num_commits" -gt 0 ]; then
            # (see http://stackoverflow.com/a/22654961 for details)
            ( set -x; git checkout -b "$1"; git branch -f master HEAD~${num_commits}; git branch -u origin/master "$1" )
        fi
    fi
}

# git - create new branch (that tracks origin/master)
function gcbm() {
    arguments=( '<new-branch-name>' )
    if in_git_repo && num_arguments_ok arguments[@] "$#"
    then
        ( set -x; git checkout -b "$1" origin/master )
    fi
}

# git - push current local branch to origin, and set upstream
function gpb() {
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git push -u origin "$branch_name" )
    fi
}

# TODO: git - create reviewboard (git review)
# function gr() {
#     while read -r line
#     do
#         echo "$line"
#         # TODO: grep line for the URL of the reviewboard, and open that in Chrome after the
#         # command completes
#         # echo -e "\ny" | git review
#     done < <( set -x; git review )
# }

# git - rebase current branch against master
function gram() {
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git checkout master && git pull --rebase && git checkout "$branch_name" && git rebase master )
        if [ "$?" -ne 0 ]; then
            # TODO - test this
            ( set -x; git mergetool --tool=opendiff && git rebase --continue )
        fi
    fi
}

# git - rebase current branch against master (using 'mint update' instead of 'git pull')
function mram() {
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git checkout master && mint update && git checkout "$branch_name" && git rebase master )
    fi
}

# git - show which files are different from master branch
function gfiles() {
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git diff --name-status master.."$branch_name" )
    fi
}

# git - squash commits in current branch into a single commit
function gsqb() {
    arguments=( '<commit-message>' )
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
    then
        local num_commits_on_branch="$(commit_diff_on_branch "$(current_git_branch)")"
        echo "There are ${num_commits_on_branch} commits to squash"
        squash_commits "$num_commits_on_branch" "$1"
    else
        return -1;
    fi
}

# git - squash commits, "rebase", merge, and submit (for LI workflow)
function gsubmit() {
    arguments=( '<commit-message>' )
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)

        # number of changes that need to be squashed
        local git_rev_list_origin=$( set -x; git rev-list --count --left-right ${branch_name}...origin/master 2>/dev/null )
        if [ "$?" -eq 0 ] && [ -n "$git_rev_list_origin" ]; then
            local git_origin_arr=($git_rev_list_origin) # will split into array because it's 2 numbers separated by spaces
            local num_commits_on_branch="${git_origin_arr[0]}"
            echo "There are ${num_commits_on_branch} commits on branch '${branch_name}'"

            # "rebase" without having to do things interactively (from Stack Overflow)
            ( set -x; git reset --soft HEAD~${num_commits_on_branch} && git commit -m "$1" )
            if [ "$?" -eq 0 ]; then
                # TODO - figure out how to recover from these
                # apply the RB to the commit
                # if this fails, means you don't have the necessary ACLs
                ( set -x; git review dcommit )
                # rebase against master
                ( set -x; git pull --rebase origin master && git checkout master && git pull --rebase )
                # merge into master
                ( set -x; git merge ${branch_name} )
                # and submit
                ( set -x; git submit )
                if [ "$?" -ne 0 ]; then
                    # submit failed, could be precommit, or ACL check, or whatever
                    echoerr "Dang it! \"git submit\" failed, undoing the merge"
                    ( set -x; git reset --merge ORIG_HEAD && git checkout ${branch_name} )
                    return -1
                fi
                echoack "success! pulling changes into master"
                # rebase to pick up the change
                ( set -x; git pull --rebase )
                # and done!
            else
                # TODO what do I do if there is some error here?
                echoerr "Dang it! \"rebasing\" didn't work"
            fi
        else
            # at this point there were no changes made, so nothing to do here
            echoerr "Dang it! Couldn't figure out how many changes to squash"
        fi
    fi
}

# TODO - reuse functions from gsubmit
# git - squash commits, "rebase", merge, and mint submit (for LI workflow)
function msubmit() {
    arguments=( '<commit-message>' ) # optional: <review-ID>
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_min arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)

        # number of changes that need to be squashed
        local git_rev_list_origin=$( set -x; git rev-list --count --left-right ${branch_name}...origin/master 2>/dev/null )
        if [ "$?" -eq 0 ] && [ -n "$git_rev_list_origin" ]; then
            local git_origin_arr=($git_rev_list_origin) # will split into array because it's 2 numbers separated by spaces
            local num_commits_on_branch="${git_origin_arr[0]}"
            echo "There are ${num_commits_on_branch} commits on branch '${branch_name}'"

            # "rebase" without having to do things interactively (from Stack Overflow)
            ( set -x; git reset --soft HEAD~${num_commits_on_branch} && git commit -m "$1" )
            if [ "$?" -eq 0 ]; then
                # TODO - figure out how to recover from these
                # apply the RB to the commit
                if [ -n "$2" ]; then
                    # with review-ID (if I initially did 'git review' on master instead of a branch)
                    ( set -x; git review dcommit -r "$2")
                else
                    ( set -x; git review dcommit )
                fi
                # TODO - this will fail if I need acl checks, parse the output for who to ask for reviews
                # rebase against master
                ( set -x; git pull --rebase origin master && git checkout master && git pull --rebase )
                # merge into master
                ( set -x; git merge ${branch_name} )
                # and submit
                ( set -x; mint submit )
                # mint submit is async, so for now undo the merge in case I have to resubmit
                echoack "Done, undoing the merge so I can keep working"
                ( set -x; git reset --merge ORIG_HEAD && git checkout ${branch_name} )
            else
                # TODO what do I do if there is some error here?
                echoerr "Dang it! \"rebasing\" didn't work"
            fi
        else
            # at this point there were no changes made, so nothing to do here
            echoerr "Dang it! Couldn't figure out how many changes to squash"
        fi
    fi
}

# git - branch move (rename current branch)
function gbm() {
    arguments=( '<new-branch-name>' )
    if in_git_repo && num_arguments_ok arguments[@] "$#"
    then
        ( set -x; git branch --move "$1" )
    fi
}

# git - wait on github to be pingable (pings every 60 seconds)
function wait_github() {
    until ping -i 60 -o github.com
    do
        sleep 60
    done
    echoack "github available"
}

