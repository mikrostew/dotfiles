#!/usr/bin/env bash
# $DOTFILES_DIR/.bash_git: git aliases and functions, sourced from .bashrc

require "$DOTFILES_DIR/.bash_colors"
require "$DOTFILES_DIR/.bash_shared_functions"


# shared functions

in_git_repo() {
    git status >/dev/null && return 0 || return 1
}

# for LinkedIn workflow
in_git_submit_repo() {
  # get the JSON showing which repos are supported for 'git submit'
  local allowed_repos_json="$(curl https://tools.corp.linkedin.com/apps/tools/commit-queue-manager/api/v1/allowed-repos/ 2>/dev/null)"
  # parse that into a list of only the repo URLs
  local allowed_repos_text="$(echo $allowed_repos_json | jq '.repos | .[] | .repo_url')"
  [[ "$allowed_repos_text" =~ "$1" ]]
  return
}

in_mint_submit_repo() {
  if [ -f "$PWD/product-spec.json" ]; then
    # test if there is something defined for 'mint submit'
    submit_def="$(cat $PWD/product-spec.json | jq '.build.commands.submit')"
    [ "$submit_def" != 'null' ]
    return
  else
    # product-spec.json does not exist
    return
  fi
}

# repo url, without the 'ssh://git@' bit at the beginning
git_repo_url() {
  # from https://stackoverflow.com/a/16880000
  echo "$(git ls-remote --get-url origin | sed -e 's/^ssh:\/\///' -e 's/^git@//')"
}

# for LinkedIn workflow
git_review_board_id() {
  echo "$(git config --get branch.$1.reviewid)"
}

current_git_branch() {
    echo "$(git rev-parse --abbrev-ref HEAD)"
}

on_git_branch() {
    [ "$(current_git_branch)" != "$1" ] && echoerr ">_<  Must be on branch '$1' for this" && return -1 || return 0
}

not_on_git_branch() {
    [ "$(current_git_branch)" == "$1" ] && echoerr ">_<  Doesn't work on branch '$1'" && return -1 || return 0
}

no_uncommitted_changes() {
    [ "$(git status --porcelain --untracked-files=no)" != "" ] && echoerr ">_<  You have uncommitted changes" && return -1 || return 0
}

# number of changes between two input branches
# (typically a branch and master, or master and origin/master)
commit_diff_on_branch() {
    local git_rev_list_origin="$(git rev-list --count --left-right "$1"..."$2" 2>/dev/null)"
    if [ "$?" -eq 0 ] && [ -n "$git_rev_list_origin" ]; then
        local git_origin_arr=($git_rev_list_origin) # splits into array - it's 2 numbers separated by spaces
        echo "${git_origin_arr[0]}"
    else
        echo "0"
    fi
}

# files changed on the current branch
file_diff_on_branch() {
  local tracking_branch="$(based_on_master_or_origin)"
  echo "$(git diff-tree --no-commit-id --name-only -r "$tracking_branch" HEAD)"
}

based_on_master_or_origin() {
  # adapted from https://stackoverflow.com/a/9753364
  local tracking_branch="$(git rev-parse --abbrev-ref --symbolic-full-name $1@{u} 2>/dev/null)"
  if [ "$tracking_branch" == "origin/master" ]; then
    echo "origin/master"
  else
    echo "master"
  fi
}

# squash the input number of commits on the current branch
# $1: number of commits to squash
# $2: commit message
# $3: extra line for message (extra info, overrides, etc.)
squash_commits() {
    if [ -n "$1" ] && [ "$1" -gt 0 ]; then
        if [ -n "$2" ]; then
            if [ -n "$3" ]; then
                # multiple lines of commit messages
                do_git reset --soft HEAD~${1} && do_git commit -m "$2" -m "$3"
            else
                # "squash" commits by combining all into a single commit (from SO)
                do_git reset --soft HEAD~${1} && do_git commit -m "$2"
            fi
            if [ "$?" -ne 0 ]; then
                echoerr "Dang it! Squashing commits failed somehow"
                return 1;
            fi
        else
            echoerr "Come on! You gotta have a commit message"
            return 1;
        fi
    else
        echoerr "-_- No changes to squash"
        return 1;
    fi
    return 0;
}

# run git with the input arguments
do_git() {
  do_cmd git "$@"
}


# functions

# git - apply a patch to a new branch, named after the input .patch file (from gbpatch)
gbapply() {
  arguments=('<patch-file>')
  if in_git_repo && on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
  then
    local patch_file="$1"
    local new_branch_name=$(basename "$patch_file")
    do_git checkout -b "${new_branch_name%.*}" && do_git apply --check "$patch_file" && do_git apply "$patch_file"
  fi
}

# git - list branches (git branch list)
gbl() {
  do_git branch --list
}

# git - list local and remote branches (git branch list all)
gbla() {
  do_git branch --list -a
}

# git - create a patch from the current branch (for use with gbapply)
gbpatch() {
  arguments=()
  if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
  then
    local branch_name=$(current_git_branch)
    local tracking_branch=$(based_on_master_or_origin)
    do_git format-patch $tracking_branch --stdout > "${branch_name}.patch"
  fi
}

# git - checkout branch/tag/hash (git checkout)
gc() {
  arguments=('<branch-tag-or-hash>')
  if in_git_repo && num_arguments_ok arguments[@] "$#"
  then
    do_git checkout "$1"
  fi
}

# git - create new branch
gcb() {
  arguments=( '<new-branch-name>' )
  if in_git_repo && num_arguments_ok arguments[@] "$#"
  then
    do_git checkout -b "$1"
  fi
}

# git - create new branch (that tracks origin/master)
gcbm() {
  arguments=( '<new-branch-name>' )
  if in_git_repo && num_arguments_ok arguments[@] "$#"
  then
    do_git checkout -b "$1" origin/master
  fi
}

# git - gui (git gui)
gg() {
  do_git gui
}

# git - show last commit info - (git last)
glast() {
  do_git log -n1
}

# git - run linter on files changed on this branch (git lint changes)
glc() {
  # TODO support more than *.js files
  # TODO use file_diff_on_branch to get the changed files
  eslint --config ~/dotfiles/.eslintrc.json --plugin extra-rules --rule 'extra-rules/no-commented-out-code: warn'
}

# git - run mergetool for conflicts (git mergetool)
gmt() {
  # TODO: different tool for Mac/Linux
  do_git mergetool --tool=opendiff
}

# git - push changes (git push)
gp() {
  do_git push
}

# git - push current local branch to origin, and set upstream
gpb() {
  arguments=()
  if in_git_repo && not_on_git_branch 'master' && num_arguments_ok arguments[@] "$#"
  then
    local branch_name=$(current_git_branch)
    do_git push -u origin "$branch_name"
  fi
}

# git - pull changes from origin, with rebase (git pull rebase)
gpr() {
  # sometimes `git pull --rebase` fails with "fatal: Cannot rebase onto multiple branches."
  # so try doing the full command (https://stackoverflow.com/a/35844073)
  local branch_name=$(current_git_branch)
  do_git pull origin $branch_name --rebase
}

# git - create review for LI workflow (git review)
gr() {
  # TODO: use `expect` to automatically answer the prompts, which look like this (2 prompts):
  # + git review
  # No ACL owners have been added, but review request creation process will continue.
  # Recommended reviewers are: blah (Blob Loblaw)
  # Additional reviewers (users and groups), comma-delimited [leave blank to skip]:
  # Warning: You are missing owners needed on your review to push this change.
  # Choose "n" to list owners per file and select them individually.
  # Would you like to add all owners (y or n)?: y
  # ‚†èReview request #1155923 posted.
  do_git review
}

# git - rebase current branch against master
gram() {
  arguments=()
  if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
  then
    local branch_name=$(current_git_branch)
    local need_to_remove_orig_files='no'
    do_git checkout master && gpr && do_git checkout "$branch_name" && do_git rebase master
    while [ "$?" -ne 0 ]; do
      need_to_remove_orig_files='yes'
      gmt && do_git rebase --continue
      # TODO: how to detect that I should abort?
    done
    # delete any *.orig files leftover from merge conflicts
    if [ "$need_to_remove_orig_files" == 'yes' ]; then
      echo_info "Cleaning up .orig files from merge conflicts..."
      grmorig
    fi
  fi
}

# git - show ACLs needed for review, with optional RB_ID (git review dcommit)
grd() {
  if [ -n "$1" ]
  then
    do_git review dcommit -r "$1"
  else
    do_git review dcommit
  fi
}

# git - delete *.orig files, usually leftover after merge or rebase with conflicts
grmorig() {
  ( set -x; git ls-files --others --exclude-standard | grep \.orig$ | xargs rm -v )
}

# git - update remote tracking branch (git remote update)
gru() {
  do_git remote update
}

# git - show status of RB - which ACLs are needed (git review status)
grs() {
  do_git review status
}

# git - update RB with new changes (git review update)
gru() {
  do_git review update
}

# git - stash uncommitted changes (git stash)
gs() {
  do_git stash
}

# git - apply stashed changes (git stash apply [stash])
gsa() {
  if [ -n "$1" ]; then
    do_git stash apply "$1"
  else
    do_git stash apply
  fi
}

# git - dtop stashed changes (git stash drop [stash])
gsd() {
  if [ -n "$1" ]; then
    do_git stash drop "$1"
  else
    do_git stash drop
  fi
}

# git - list all stashes (git stash list)
gsl() {
  do_git stash list
}

# git - pop the last stash (git stash pop)
gsp() {
  do_git stash pop
}

# git - stash current changes with a message (git stash save)
gss() {
  arguments=('<message>')
  if in_git_repo && num_arguments_ok arguments[@] "$#"
  then
    do_git stash save "$1"
  fi
}

# git - show repo status (git status)
gstat() {
  do_git status
}

# git - undo the last commit (git undo)
gundo() {
  do_git reset --soft HEAD~1
}

# git - (meta) show git functions from this file
gfun() {
  printf "\nFunctions:\n"
  # list of functions and descriptions
  git_functions=$(sed -n -e '/^# git/{ h; n; G; s/\n//; s/{# git - //; p; }' "$DOTFILES_DIR/.bash_git" | sort)
  while read -r func text; do
    printf "%10s - %s\n" "$func" "$text"
  done <<< "$git_functions"
}

# git - show the current commit hash
gcurr() {
    arguments=()
    if in_git_repo && num_arguments_ok arguments[@] "$#"
    then
        ( set -x; git rev-parse HEAD; git rev-parse --short HEAD; )
    fi
}

# git - sync current branch to the upstream fork (Git Fork Sync)
gfs() {
    arguments=()
    if in_git_repo && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git fetch upstream; git merge "upstream/$branch_name"; git push )
    fi
}

# git - merge current branch into master
gmm() {
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git checkout master && git merge "$branch_name" )
    fi
}

# git - move recent commits to a new branch (instead of master)
gmove() {
    arguments=( '<new-branch-name>' )
    if in_git_repo && on_git_branch 'master' && num_arguments_ok arguments[@] "$#"
    then
        local num_commits="$(commit_diff_on_branch 'master' 'origin/master')"
        echo "${num_commits} commit(s) will be moved to branch '$1'"
        if [ "$num_commits" != "" ] && [ "$num_commits" -gt 0 ]; then
            # (see http://stackoverflow.com/a/22654961 for details)
            ( set -x; git checkout -b "$1"; git branch -f master HEAD~${num_commits}; git branch -u origin/master "$1" )
        fi
    fi
}

# git - rebase current branch against master (using 'mint update' instead of 'git pull')
mram() {
    # TODO: use gram() and check if I'm in a MP
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git checkout master && mint update && git checkout "$branch_name" && git rebase master )
    fi
}

# git - show which files are different from master branch
gfiles() {
    arguments=()
    if in_git_repo && not_on_git_branch 'master' && num_arguments_ok arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        ( set -x; git diff --name-status master.."$branch_name" )
    fi
}

# git - squash commits in current branch into a single commit (git squash branch)
gsqb() {
    arguments=( '<commit-message> [, <extra-line>]' )
    if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_min arguments[@] "$#"
    then
        local branch_name=$(current_git_branch)
        local based_on=$(based_on_master_or_origin $branch_name)
        # TODO: this may not be what I want in all situations?
        local num_commits_on_branch="$(commit_diff_on_branch $branch_name $based_on)"
        echo_info "$num_commits_on_branch change(s) between '$branch_name' and '$based_on'"
        squash_commits "$num_commits_on_branch" "$1" "$2"
    else
        return -1;
    fi
}

# git - squash commits, rebase, merge, and submit (for LI workflow)
gsubmit() {
  arguments=( '<commit-message> [, <extra-line>]' )
  if in_git_repo && not_on_git_branch 'master' && no_uncommitted_changes && num_arguments_min arguments[@] "$#"
  then
    local branch_name=$(current_git_branch)

    # squash changes on this branch
    gsqb "$1" "$2"
    if [ "$?" -ne 0 ]; then
      echoerr "Dang it! squashing failed (TODO: auto recovery here?)"
      return 1
    fi

    local review_id="$(git_review_board_id $branch_name)"
    echo_info "Review ID: $review_id"

    # rebase against master
    do_git pull --rebase origin master && do_git checkout master && do_git pull --rebase
    while [ "$?" -ne 0 ]; do
      read -p "Press any key to continue... " -n1 -s # DEBUG
      gmt && do_git rebase --continue
      # TODO: how to detect that I should abort?
    done

    # merge into master
    do_git merge "$branch_name"
    if [ "$?" -ne 0 ]; then
      echoerr "Dang it! merge failed - good luck (TODO: auto recovery)"
      gmt
      read -p "Press any key to continue... " -n1 -s # DEBUG
    fi

    # apply the RB to the commit
    # if this fails, means I don't have the necessary ACLs
    do_git review dcommit -r "$review_id"
    if [ "$?" -ne 0 ]; then
      # dcommit failed, probably missing a shipit from ACL
      echoerr "Dang it! \"git review dcommit\" failed, undoing the merge"
      do_git reset --merge ORIG_HEAD && do_git checkout "$branch_name"
      return 1
    fi

    # check if can use 'git submit' (LinkedIn), otherwise need to 'git push'
    local repo_url="$(git_repo_url)"
    echo_info "repo URL: '$repo_url'"
    if in_git_submit_repo "$repo_url"; then
      echo_info "git submit - OK"

      # also, check product-spec.json for 'mint submit'
      if in_mint_submit_repo; then
        echo_info "mint submit - OK"
        # mint submit
        do_cmd mint submit
        if [ "$?" -ne 0 ];then echoerr "Failed :("; else echoack "Success :)"; fi
        # mint submit is async, so for now undo the merge in case I have to resubmit
        echo_info "Undoing the merge so I can keep working"
        do_git reset --merge ORIG_HEAD && do_git checkout "$branch_name"
      else
        echo_info "mint submit - not supported"
        # git submit
        do_git submit
        if [ "$?" -ne 0 ]; then
          # submit failed, could be precommit, or ACL check, or whatever
          echoerr "Dang it! \"git submit\" failed, undoing the merge"
          do_git reset --merge ORIG_HEAD && do_git checkout "$branch_name"
          return 1
        fi
        echoack "Success! Pulling changes into master"
        # rebase to pick up the change
        gpr
        # and done!
      fi
    else
      echo_info "git submit - not supported, pushing..."
      do_git push
      if [ "$?" -ne 0 ]; then
        # push failed
        echoerr "Dang it! \"git push\" failed, undoing the merge"
        # TODO: should have a function for this:
        do_git reset --merge ORIG_HEAD && do_git checkout "$branch_name"
        return 1
      fi
      echoack "Success!"
    fi
  fi
}

# git - branch move (rename current branch)
gbm() {
    arguments=( '<new-branch-name>' )
    if in_git_repo && num_arguments_ok arguments[@] "$#"
    then
        ( set -x; git branch --move "$1" )
    fi
}

# TODO: generalize this for whatever input URL
# git - wait on github to be pingable (pings every 60 seconds)
wait_github() {
    until ping -i 60 -o github.com
    do
        sleep 60
    done
    echoack "github available"
}

# TODO: nuke MP (e.g. voyager-web) to clean state, update, init
# ( git clean -fdx; mint update; just init )
