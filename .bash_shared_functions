#!/usr/bin/env bash
# $DOTFILES_DIR/.bash_shared_functions: library of shared functions, sourced from multiple files

# colors
require "$DOTFILES_DIR/.bash_colors"


# echo to stderr with red text
echo_err() {
  echo -e "${COLOR_FG_RED}$@${COLOR_RESET}" >&2
}

# echo to stderr with green text
echo_ack() {
  echo -e "${COLOR_FG_GREEN}$@${COLOR_RESET}" >&2
}

# echo to stderr with blue text
echo_info() {
  echo -e "${COLOR_FG_BOLD_BLUE}$@${COLOR_RESET}" >&2
}

# for deprecations
# echo to stderr with yellow text
echo_dep() {
  echo -e "${COLOR_FG_BOLD_YELLOW}[DEPRECATION] $@${COLOR_RESET}" >&2
}

# show a glaringly obvious banner for success or failure
echo_fail_banner() {
  echo_err "***************";
  echo_err "*  Failed :(  *";
  echo_err "***************";
}
echo_success_banner() {
  echo_ack "****************";
  echo_ack "*  Success :)  *";
  echo_ack "****************";
}

# check for exact number of arguments to a function, and print usage if not correct
# argument(s)
# - array of expected argument names
# - number of arguments passed to function
num_arguments_ok() {
    local expected_args=( "${!1}" )
    local num_args="$2"
    local expected_num_args="${#expected_args[@]}"
    if [ "$expected_num_args" -ne "$num_args" ]
    then
        # $FUNCNAME is an array of the current call stack
        echo_err "Come on! This is how to use this:"
        echo_err ""
        echo_err "  ${FUNCNAME[1]} ${expected_args[*]}"
        return -1
    fi
    return 0
}

# check for minimum number of arguments to a function, and print usage if not correct
# argument(s)
# - array of expected argument names
# - number of arguments passed to function
# TODO: better way to handle this
num_arguments_min() {
  expected_args=( "${!1}" )
  num_args="$2"

  mandatory_args=()
  for arg in "${expected_args[@]}"
  do
    # if argument is not enclosed in [ ] it is mandatory
    if [[ "$arg" != [* ]]; then
      mandatory_args+=( "$arg" )
    fi
  done

  mandatory_num_args="${#mandatory_args[@]}"
  if [ "$num_args" -lt "$mandatory_num_args" ]
  then
    # $FUNCNAME is an array of the current call stack
    echo_err "Come on! This is how to use this:"
    echo_err ""
    echo_err "  ${FUNCNAME[1]} ${expected_args[*]}"
    return -1
  fi
  return 0
}

# echo the input command and arguments in green, then run the command
# (for commands that change state)
do_cmd() {
  echo -en "${COLOR_FG_GREEN}( " >&2
  for arg in "$@"
  do
    # double quotes around any arguments that contain spaces
    # (adapted from https://stackoverflow.com/a/1474056/)
    case "$arg" in
      *\ * )
        echo -n "\"$arg\" "
        ;;
      *)
        echo -n "$arg "
        ;;
    esac
  done
  echo -e ")${COLOR_RESET}" >&2
  command "$@"
}

# nvm
# not done automatically, because this slows down new session startup, and I use it infrequently
load_nvm() {
  echo_info "Loading nvm..."
  export NVM_DIR="$HOME/.nvm"
  [ -s "$NVM_DIR/nvm.sh" ] && source "$NVM_DIR/nvm.sh"  # This loads nvm
  [ -s "$NVM_DIR/bash_completion" ] && source "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

  # show version, if that didn't work
  min_version_check "node" "^1.0.0" 'nvm current' 'brew install node' 'echo $NVM_BIN'
}

# notion
# not done automatically, because some of the shims are not yet implemented
load_notion() {
  echo_info "Loading notion..."

  export NOTION_HOME="$HOME/.notion"
  [ -s "$NOTION_HOME/load.sh" ] && \. "$NOTION_HOME/load.sh"

  export PATH="${NOTION_HOME}/bin:$PATH"

  # check version
  # min_version_check "notion" "^0.1.0" 'notion --version' 'TODO' 'echo $NOTION_HOME'
}

# because I frequently screw up my installation
install_notion() {
  echo_ack "( curl -sSLf https://get.notionjs.com | bash )"
  curl -sSLf https://get.notionjs.com | bash
}

# chruby
# not done automatically because I infrequently use ruby and this clutters the path
load_chruby() {
  echo_info "Loading chruby..."
  # this is the same location on mac and linux
  if [ -f "/usr/local/share/chruby/chruby.sh" ]; then
    source /usr/local/share/chruby/chruby.sh
    chruby ruby-2
    ruby -v
  fi

  min_version_check "ruby" "^2.2.0" 'echo $RUBY_VERSION' '(something with ruby-install)' 'echo $RUBY_ROOT';
}

# latex
# not done automatically because I infrequently use TeX/LaTeX, and it clutters the path
load_latex() {
  echo_info "Adding TeX/LaTeX binaries to the path..."
  export PATH="/Library/TeX/texbin:$PATH"
  echo "$PATH"
}
