#!/usr/bin/env bash
# $DOTFILES_DIR/.bash_shared_functions: library of shared functions, sourced from multiple files

# colors
require "$DOTFILES_DIR/.bash_colors"


# echo to stderr with red text
echoerr() {
    echo -e "${COLOR_FG_RED}$@${COLOR_RESET}" >&2
}

# echo to stdout with green text
echoack() {
    echo -e "${COLOR_FG_GREEN}$@${COLOR_RESET}"
}

# echo to stdout with blue text
echo_info() {
    echo -e "${COLOR_FG_BOLD_BLUE}$@${COLOR_RESET}"
}

# check for exact number of arguments to a function, and print usage if not correct
# argument(s)
# - array of expected argument names
# - number of arguments passed to function
num_arguments_ok() {
    local expected_args=( "${!1}" )
    local num_args="$2"
    local expected_num_args="${#expected_args[@]}"
    if [ "$expected_num_args" -ne "$num_args" ]
    then
        # $FUNCNAME is an array of the current call stack
        echoerr "Come on! This is how to use this:"
        echoerr ""
        echoerr "  ${FUNCNAME[1]} ${expected_args[*]}"
        return -1
    fi
    return 0
}

# check for minimum number of arguments to a function, and print usage if not correct
# argument(s)
# - array of expected argument names
# - number of arguments passed to function
# TODO: better way to handle this
num_arguments_min() {
    local expected_args=( "${!1}" )
    local num_args="$2"
    local expected_num_args="${#expected_args[@]}"
    if [ "$num_args" -lt "$expected_num_args" ]
    then
        # $FUNCNAME is an array of the current call stack
        echoerr "Come on! This is how to use this:"
        echoerr ""
        echoerr "  ${FUNCNAME[1]} ${expected_args[*]}"
        return -1
    fi
    return 0
}

# echo the input command and arguments, then run the command
do_cmd() {
  echo -e "${COLOR_FG_GREEN}($@)${COLOR_RESET}" >&2
  # TODO: eventually take away the 'set -x' once I feel comfortable that I haven't screwed up any commands
  ( set -x; "$@" )
}

# trim leading and trailing double quotes
trim_double_quotes() {
  local string="$1"
  string="${string#\"}"
  string="${string%\"}"
  echo "$string"
}

# nvm
# not done automatically, because this slows down new session startup, and I use it infrequently
load_nvm() {
  echo_info "Loading nvm..."
  export NVM_DIR="$HOME/.nvm"
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"  # This loads nvm
  [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

  # show version, if that didn't work
  min_version_check "node" "1.*.*" 'nvm current' 'echo $NVM_BIN'
}

