#!/usr/bin/env bash
# $DOTFILES_DIR/.bash_shared_functions: library of shared functions, sourced from multiple files

# colors
require "$DOTFILES_DIR/.bash_colors"


# echo to stderr with red text
echoerr() {
  echo_dep "use echo_err() instead of echoerr()"
  echo_err "$@"
}
echo_err() {
  echo -e "${COLOR_FG_RED}$@${COLOR_RESET}" >&2
}

# echo to stderr with green text
echoack() {
  echo_dep "use echo_ack() instead of echoack()"
  echo_ack "$@"
}
echo_ack() {
  echo -e "${COLOR_FG_GREEN}$@${COLOR_RESET}" >&2
}

# echo to stderr with blue text
echo_info() {
  echo -e "${COLOR_FG_BOLD_BLUE}$@${COLOR_RESET}" >&2
}

# for deprecations
# echo to stderr with yellow text
echo_dep() {
  echo -e "${COLOR_FG_BOLD_YELLOW}[DEPRECATION] $@${COLOR_RESET}" >&2
}

# show a glaringly obvious banner for success or failure
echo_fail_banner() {
  echo_err "***************";
  echo_err "*  Failed :(  *";
  echo_err "***************";
}
echo_success_banner() {
  echo_ack "****************";
  echo_ack "*  Success :)  *";
  echo_ack "****************";
}

# check for exact number of arguments to a function, and print usage if not correct
# argument(s)
# - array of expected argument names
# - number of arguments passed to function
num_arguments_ok() {
    local expected_args=( "${!1}" )
    local num_args="$2"
    local expected_num_args="${#expected_args[@]}"
    if [ "$expected_num_args" -ne "$num_args" ]
    then
        # $FUNCNAME is an array of the current call stack
        echo_err "Come on! This is how to use this:"
        echo_err ""
        echo_err "  ${FUNCNAME[1]} ${expected_args[*]}"
        return -1
    fi
    return 0
}

# check for minimum number of arguments to a function, and print usage if not correct
# argument(s)
# - array of expected argument names
# - number of arguments passed to function
# TODO: better way to handle this
num_arguments_min() {
    local expected_args=( "${!1}" )
    local num_args="$2"
    local expected_num_args="${#expected_args[@]}"
    if [ "$num_args" -lt "$expected_num_args" ]
    then
        # $FUNCNAME is an array of the current call stack
        echo_err "Come on! This is how to use this:"
        echo_err ""
        echo_err "  ${FUNCNAME[1]} ${expected_args[*]}"
        return -1
    fi
    return 0
}

# echo the input command and arguments, then run the command
do_cmd() {
  # echo -e "${COLOR_FG_GREEN}($@)${COLOR_RESET}" >&2
  echo_ack "($@)"
  # TODO: eventually take away the 'set -x' once I feel comfortable that I haven't screwed up any commands
  ( set -x; "$@" )
}

# trim leading and trailing double quotes
trim_double_quotes() {
  local string="$1"
  string="${string#\"}"
  string="${string%\"}"
  echo "$string"
}

# nvm
# not done automatically, because this slows down new session startup, and I use it infrequently
load_nvm() {
  echo_info "Loading nvm..."
  export NVM_DIR="$HOME/.nvm"
  [ -s "$NVM_DIR/nvm.sh" ] && source "$NVM_DIR/nvm.sh"  # This loads nvm
  [ -s "$NVM_DIR/bash_completion" ] && source "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

  # show version, if that didn't work
  min_version_check "node" "1.*.*" 'nvm current' 'brew install node' 'echo $NVM_BIN'
}

# notion
# not done automatically, because some of the shims are not yet implemented
load_notion() {
  echo_info "Loading notion..."

  export NOTION_HOME="$HOME/.notion"
  export PATH="${NOTION_HOME}/bin:${NOTION_HOME}/shim:$PATH"

  # check version
  min_version_check "notion" "0.1.*" 'notion --version' 'TODO' 'echo $NOTION_HOME'
}

# chruby
# not done automatically because I infrequently use ruby and this clutters the path
load_chruby() {
  echo_info "Loading chruby..."
  # TODO: is this the same on mac and linux?
  if [ -f "/usr/local/share/chruby/chruby.sh" ]; then
    source /usr/local/share/chruby/chruby.sh
    chruby ruby-2
  fi

  min_version_check "ruby" "2.2.*" 'echo $RUBY_VERSION' '(something with ruby-install)' 'echo $RUBY_ROOT';
}
